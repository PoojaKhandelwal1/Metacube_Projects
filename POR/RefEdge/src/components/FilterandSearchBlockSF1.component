<apex:component controller="RefSearchBlockController">
<html xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <head>

        <style>
            .appliedFiltersBlock {
                font-size: 0.8rem;
                padding: 0.1rem 0.8rem;
                height: 1.95rem;
                overflow-y: hidden;
                transition: all .3s ease-in-out;
                z-index: 99;
            }
            .appliedFiltersBlockOpen {
                height: 100vh;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                background-color: white;
                overflow-y: scroll;
            }
            .topPadding {
                padding-top: 1.95rem;
            }
            .textSearchBlock {
                padding: 0.1rem 2.5rem 0.3rem 2.5rem;
            }
            .filtersModal {
                position: fixed;
                top: 100%;
                bottom: 0;
                left: 0;
                right: 0;
                background-color: white;
                z-index: 999;
                padding: 0.25rem;
                transition: top .3s ease-in-out, right 0.3s ease-in-out;
                box-shadow: 0 -2px 2px 0 rgba(0, 0, 0, 0.16);
            }
            .filtersModalOpen {
                top: 0;
            }
            .filtersModalOpen1 {
                right: 100%;
            }
            .attributesModal {
                position: fixed;
                top: 0;
                bottom: 0;
                left: 100%;
                right: 0;
                background-color: white;
                z-index: 999;
                padding: 0.25rem;
                transition: all .3s ease-in-out;
                box-shadow: -2px 0 2px 0 rgba(0, 0, 0, 0.16);
            }
            .attributesModalOpen {
                left: 0;
            }
            .customIconContainer {
                height: 1.8rem !important;
                width: 1.8rem !important;
                border-radius: 0.9rem !important;
                line-height: 1 !important;
                padding: 0.5em 0 !important;
            }
            .modalBackdrop {
                position: fixed;
                top: 0;
                bottom: 0;
                left: 0;
                right: 0;
                background-color: transparent;
                z-index: 1010;
            }
            .operatorContainer {
                position: fixed;
                bottom: 3rem;
                left: 0;
                right: 0;
                background-color: white;
                z-index: 1020;
                transition: all .15s ease-in-out;
                box-shadow: 0 -2px 2px 0 rgba(0, 0, 0, 0.16);
                height: 0;
                overflow: hidden;
            }
            .operatorContainerOpen {
                height: 4.5rem;
            }
        </style>

        <script>
            var sf1FilterCtrl = sf1RefSearchApp.controller('sf1FilterCtrl',
                function($scope, $q, productService, $timeout) {
                    $scope.basicFilters = [];
                    $scope.isUserMappingSaved = false;
                    $scope.basicFilterMap = {};
                    $scope.attributeList = [];
                    $scope.selectedAttributes = [];
                    $scope.filterAttributeMap = {};
                    //$scope.tempFilterAttributeMap = null;
                    $scope.mod = 0;
                    //$scope.operation = 'or';
                    $scope.operation = '{!JSENCODE(searchFilterDefault)}';
                    $scope.filterOperationMap = {};
                    $scope.Field_API_Name = 'Field_API_Name__c';
                    $scope.From_Mapping = 'From_Mapping__c';
                    $scope.Label = 'Label__c';
                    $scope.Order = 'Order__c';
                    $scope.nameSpace = '{!JSENCODE(nameSpace)}';
                    $scope.searchText = '';
                    $scope.showAllFilters = false;
                    $scope.showAdvanceFilters = false;
                    $scope.showFilterSelectionModal = false;
                    //$scope.showColumnSelectionModal = false;
                    $scope.searchBoxError = false;
                    $scope.filterIds = [];
                    $scope.mappedFilterIds = [];
                    //$scope.isloading = true;
                    $scope.relatedFilterMapAccount = {};
                    $scope.relatedFilterMapContact = {};
                    $scope.relatedFilterMapContent = {};
                    $scope.filterObj;
                    $scope.stageFilterId = '';
                    $scope.stageErrorMessage = '';
                    $scope.showextraattributes = false;
                    $scope.hasBulkRecords = false;
                    $scope.previouslySelectedAttLabel = [];
                    $scope.previouslySelectedAtt = [];
                    $scope.searchAttText = '';
                    $scope.attributeMapInheritableAccountIds = [];
                    $scope.accountMappedIds = [];
                    $scope.contactMappedIds = [];
                    $scope.contentMappedIds = [];
                    $scope.mappingSelected = false;
                    $scope.mappingContactSelected = false;
                    $scope.mappingContentSelected = false;
                    $scope.isSearchApplied = false;
                    $scope.isFilterApplied = false;
                    $scope.showFiltersModal = false;
                    $scope.attributesLoading = false;
                    $scope.isAppliedFiltersOpen = false;
                    $scope.showFilterOperatorPanel = false;

                    $scope.intialFunction = function() {
                        $scope.basicFilters = [];

                        $scope.getbasicFilters().then(function(result) {
                            $scope.basicFilters = result;

                            angular.forEach(
                                $scope.basicFilters,
                                function(filter) {
                                    $scope.basicFilterMap[filter.dataMapping[$scope.nameSpace + $scope.Field_API_Name]] = false;

                                    if (!filter.dataMapping[$scope.nameSpace + $scope.From_Mapping]) {
                                        $scope.filterIds.push(filter.dataMapping[$scope.nameSpace + $scope.Field_API_Name]);
                                    } else {
                                        $scope.mappedFilterIds.push(filter.dataMapping[$scope.nameSpace + $scope.Field_API_Name]);
                                    }
                                    $scope.filterOperationMap[filter.dataMapping[$scope.nameSpace + $scope.Field_API_Name]] = $scope.operation;
                                }
                            );
                        });
                        
                        if ($scope.preFilter) {
                        	var showRefContent = false;
                        	
                        	if (!$scope.forAccount && !$scope.forContent) {
                        		showRefContent = true;
                        	} else {
                        		
                        		if ($scope.forAccount) {
                        			showRefContent = false;
                        		} else if ($scope.forContent) {
                        			showRefContent = true;
                        		}
                        	}

                            $scope.getPreFilterResults(showRefContent).then(function(result) {
                                var tempResult = result.split('#');
                                $scope.stageFilterId = tempResult[1];
                                $scope.filterAttributeMap = JSON.parse(tempResult[0]);
                                $scope.stageErrorMessage = tempResult[2];
                                
                                if ($scope.stageErrorMessage != '') {
                                    productService.stageErrorEvent($scope.stageErrorMessage);
                                }
                                $scope.saveAttributes();
                            });
                        } else {
                        	
                            $scope.getStageFilterId().then(function(result) {
                                $scope.stageFilterId = result;
                            });
                        }
                    };
                    
                    $scope.getStageFilterId = function() {
                        var deferred = $q.defer();
                        
                        Visualforce.remoting.Manager.invokeAction(
                            '{!$RemoteAction.RefSearchBlockController.getStageFilterId}',
                            function(result, event) {
                                result = $scope.parseResult(result);
                                deferred.resolve(result);
                            }
                        );
                        return deferred.promise;
                    }
                    
                    $scope.getbasicFilters = function() {
                        var deferred = $q.defer();
                        
                        Visualforce.remoting.Manager.invokeAction(
                            '{!$RemoteAction.RefSearchBlockController.getbasicFilters}',
                            function(result, event) {
                                result = $scope.parseResult(result);
                                deferred.resolve(JSON.parse(result));
                            }
                        );
                        return deferred.promise;
                    }

                    $scope.getPreFilterResults = function(showRefContent) {
                        var deferred = $q.defer();
                        
                        Visualforce.remoting.Manager.invokeAction(
                            '{!$RemoteAction.RefSearchBlockController.getPreFilterResults}',
                            $scope.opportunityId, showRefContent,
                            function(result, event) {
                                result = $scope.parseResult(result);
                                deferred.resolve(result);
                            }
                        );
                        return deferred.promise;
                    }

                    $scope.getAllFilterAttributes = function() {
                        var deferred = $q.defer();
                        
                        Visualforce.remoting.Manager.invokeAction(
                            '{!$RemoteAction.RefSearchBlockController.getAllFilterAttributes}',
                            angular.toJson($scope.filterIds),
                            function(result, event) {
                                deferred.resolve(result);
                            }
                        );
                        return deferred.promise;
                    }

                    $scope.getReferenceability = function() {
                        var deferred = $q.defer();
                        
                        Visualforce.remoting.Manager.invokeAction(
                            '{!$RemoteAction.RefSearchBlockController.getReferenceability}',
                            function(result, event) {
                                deferred.resolve(result);
                            }
                        );
                        return deferred.promise;
                    }

                    $scope.getContentLanguage = function() {
                        var deferred = $q.defer();
                        
                        Visualforce.remoting.Manager.invokeAction(
                            '{!$RemoteAction.RefSearchBlockController.getContentLanguage}',
                            function(result, event) {
                                deferred.resolve(result);
                            }
                        );
                        return deferred.promise;
                    }

                    $scope.getContentTypes = function() {
                        var deferred = $q.defer();
                        
                        Visualforce.remoting.Manager.invokeAction(
                            '{!$RemoteAction.RefSearchBlockController.getContentTypes}',
                            function(result, event) {
                                deferred.resolve(result);
                            }
                        );
                        return deferred.promise;
                    }

                    $scope.getRelatedFilterAttributes = function(id) {
                        var deferred = $q.defer();
                        
                        Visualforce.remoting.Manager.invokeAction(
                            '{!$RemoteAction.RefSearchBlockController.getRelatedFilterAttributes}', id,
                            function(result, event) {
                                deferred.resolve(result);
                            }
                        );
                        return deferred.promise;
                    }

                    $scope.getFilterAttributes = function(id) {
                        var deferred = $q.defer();
                        
                        Visualforce.remoting.Manager.invokeAction(
                            '{!$RemoteAction.RefSearchBlockController.getFilterAttributes}', id,
                            function(result, event) {
                                deferred.resolve(result);
                            }
                        );
                        return deferred.promise;
                    }

                    $scope.searchRelatedMAppingAttributes = function(id) {
                        var deferred = $q.defer();
                        
                        Visualforce.remoting.Manager.invokeAction(
                            '{!$RemoteAction.RefSearchBlockController.searchRelatedMAppingAttributes}',
                            id, $scope.searchAttText,
                            function(result, event) {
                                deferred.resolve(result);
                            }
                        );
                        return deferred.promise;
                    }

                    $scope.filterRecords = function(previouslySelectedAttLabel, relatedFilterId) {
                        var deferred = $q.defer();
                        
                        Visualforce.remoting.Manager.invokeAction(
                            '{!$RemoteAction.RefSearchBlockController.filterRecords}',
                            relatedFilterId, angular.toJson(previouslySelectedAttLabel),
                            function(result, event) {
                                result = $scope.parseResult(result);
                                deferred.resolve(JSON.parse(result));
                            }
                        );
                        return deferred.promise;
                    }

                    $scope.getMapping = function(mappingIds) {
                        var deferred = $q.defer();
                        
                        Visualforce.remoting.Manager.invokeAction(
                            '{!$RemoteAction.RefSearchBlockController.getMappingRecords}',
                            angular.toJson(mappingIds),
                            function(result, event) {
                                result = $scope.parseResult(result);
                                deferred.resolve(JSON.parse(result));
                            }
                        );
                        return deferred.promise;
                    }

                    $scope.getContacts = function(attributeMapInheritableContactIds, isInheritableMappingFromContact) {
                        var deferred = $q.defer();
                        
                        if (isInheritableMappingFromContact) {
                            
                            Visualforce.remoting.Manager.invokeAction(
                                '{!$RemoteAction.RefSearchBlockController.getContactRecords}',
                                angular.toJson(attributeMapInheritableContactIds),
                                function(result, event) {
                                    result = $scope.parseResult(result);
                                    deferred.resolve(JSON.parse(result));
                                }
                            );
                        } else {
                            deferred.resolve('');
                        }
                        return deferred.promise;
                    }

                    $scope.getContents = function(attributeMapInheritableContentIds, isInheritableMappingFromContent) {
                        var deferred = $q.defer();
                        
                        if (isInheritableMappingFromContent) {
                            
                            Visualforce.remoting.Manager.invokeAction(
                                '{!$RemoteAction.RefSearchBlockController.getContentRecords}',
                                angular.toJson(attributeMapInheritableContentIds),
                                function(result, event) {
                                    result = $scope.parseResult(result);
                                    deferred.resolve(JSON.parse(result));
                                }
                            );
                        } else {
                            deferred.resolve('');
                        }
                        return deferred.promise;
                    }

                    $scope.getRelatedContacts = function(attributeMapInheritableAccountIds, isInheritableMapping) {
                        var deferred = $q.defer();
                        
                        if (isInheritableMapping) {
                            
                            Visualforce.remoting.Manager.invokeAction(
                                '{!$RemoteAction.RefSearchBlockController.getRelatedContactRecords}',
                                angular.toJson(attributeMapInheritableAccountIds),
                                function(result, event) {
                                    result = $scope.parseResult(result);
                                    deferred.resolve(JSON.parse(result));
                                }
                            );
                        } else {
                            deferred.resolve('');
                        }
                        return deferred.promise;
                    }

                    $scope.getRelatedContents = function(attributeMapInheritableAccountIds, isInheritableMapping) {
                        var deferred = $q.defer();
                        
                        if (isInheritableMapping) {
                            
                            Visualforce.remoting.Manager.invokeAction(
                                '{!$RemoteAction.RefSearchBlockController.getRelatedContentRecords}',
                                angular.toJson(attributeMapInheritableAccountIds),
                                function(result, event) {
                                    result = $scope.parseResult(result);
                                    deferred.resolve(JSON.parse(result));
                                }
                            );
                        } else {
                            deferred.resolve('');
                        }
                        return deferred.promise;
                    }

                    $scope.parseResult = function(result) {
                        result = result.replace(/&quot/gi, '"');
                        result = result.replace(/&amp/g, '&');
                        result = result.replace(/&lt/g, '<');
                        result = result.replace(/&gt/g, '>');
                        result = result.replace(/;/g, '');
                        result = result.replace(/&#39/g, '\'');
                        return result;
                    }

                    $scope.getAllAttributes = function() {
                        productService.isloading(true);
                        var tempFilterAttributeMap = angular.copy($scope.filterAttributeMap);

                        if ($scope.filterIds != null && $scope.filterIds.length > 0) {
                            
                            $scope.getAllFilterAttributes().then(function(result) {
                                $scope.tempMap = result;

                                if (angular.equals({}, tempFilterAttributeMap)) {

                                    angular.forEach(
                                        $scope.tempMap,
                                        function(array, labelId) {
                                            $scope.filterAttributeMap[labelId] = array;
                                        }
                                    );
                                } else {

                                    angular.forEach(
                                        $scope.tempMap,
                                        function(array, labelId) {

                                            if (labelId in tempFilterAttributeMap) {
                                                array = tempFilterAttributeMap[labelId];
                                            }
                                            $scope.filterAttributeMap[labelId] = array;
                                        }
                                    );
                                }

                                if ($scope.filterIds.indexOf('Content Types') < 0 && $scope.filterIds.indexOf('Content Language') < 0
                                            && $scope.filterIds.indexOf('Referenceability') < 0) {
                                    productService.isloading(false);
                                }
                            });
                        } else {
                            
                            if ($scope.filterIds.indexOf('Content Types') < 0 && $scope.filterIds.indexOf('Content Language') < 0
                            			&& $scope.filterIds.indexOf('Referenceability') < 0) {
                            	productService.isloading(false);
                            }
                        }

                        if ($scope.filterIds.indexOf('Referenceability') >= 0) {

                            $scope.getReferenceability().then(function(result) {

                                if (!angular.equals({}, tempFilterAttributeMap)) {

                                    if ('Referenceability' in tempFilterAttributeMap) {
                                        $scope.tempList = tempFilterAttributeMap['Referenceability'];
                                    } else {
                                        $scope.tempList = result;
                                    }
                                } else {
                                    $scope.tempList = result;
                                }
                                $scope.filterAttributeMap['Referenceability'] = $scope.tempList;

                                if ($scope.filterIds.indexOf('Content Types') < 0 && $scope.filterIds.indexOf('Content Language') < 0) {
                                    productService.isloading(false);
                                }
                            });
                        }

                        if ($scope.filterIds.indexOf('Content Language') >= 0) {

                            $scope.getContentLanguage().then(function(result) {

                                if (!angular.equals({}, tempFilterAttributeMap)) {

                                    if ('Content Language' in tempFilterAttributeMap) {
                                        $scope.tempList = tempFilterAttributeMap['Content Language'];
                                    } else {
                                        $scope.tempList = result;
                                    }
                                } else {
                                    $scope.tempList = result;
                                }
                                $scope.filterAttributeMap['Content Language'] = $scope.tempList;

                                if ($scope.filterIds.indexOf('Content Types') < 0) {
                                    productService.isloading(false);
                                }
                            });
                        }

                        if ($scope.filterIds.indexOf('Content Types') >= 0) {

                            $scope.getContentTypes().then(function(result) {

                                if (!angular.equals({}, tempFilterAttributeMap)) {

                                    if ('Content Types' in tempFilterAttributeMap) {
                                        $scope.tempList = tempFilterAttributeMap['Content Types'];
                                    } else {
                                        $scope.tempList = result;
                                    }
                                } else {
                                    $scope.tempList = result;
                                }
                                $scope.filterAttributeMap['Content Types'] = $scope.tempList;
                                productService.isloading(false);
                            });
                        }
                        $scope.showAllFilters = true;
                    }

                    $scope.seeAllRelatedMapping = function(id) {
                        $scope.showAllFilters = false;
                        $scope.showHideTab(id);
                    }

                    $scope.showHideTab = function(id) {
                        $scope.attributesLoading = true;
                        $scope.hasBulkRecords = false;
                        $scope.tempfilter = {};
                        $scope.showextraattributes = true;

                        angular.forEach(
                            $scope.basicFilters,
                            function(filter) {

                                if (filter.dataMapping[$scope.nameSpace + $scope.Field_API_Name] == id) {
                                    $scope.tempfilter = filter.dataMapping;
                                    $scope.filterObj = filter.dataMapping;
                                }
                            }
                        );
                        
                        if ($scope.filterAttributeMap[id] != null && $scope.tempfilter[$scope.nameSpace + $scope.From_Mapping]) {
                            $scope.attributeList = [];
                            var tempatts = $scope.filterAttributeMap[id];

                            angular.forEach(
                                tempatts,
                                function(att) {

                                    if (att.isSelected && $scope.attributeList.indexOf(att) == -1) {
                                        $scope.attributeList.push(att);
                                    }
                                }
                            );
                            $scope.operation = $scope.filterOperationMap[id];

                            if ($scope.attributeList.length == 0) {

                                $scope.getRelatedFilterAttributes(id).then(function(result) {
                                    $scope.setattributeList(result, id);
                                    $scope.attributesLoading = false;
                                });
                            } else {
                                $scope.hasBulkRecords = false;
                                $scope.attributesLoading = false;
                            }
                        }

                        if ($scope.filterAttributeMap[id] == null) {

                            if ($scope.tempfilter[$scope.nameSpace + $scope.Field_API_Name] == 'Referenceability') {
                                
                                $scope.getReferenceability().then(function(result) {
                                    $scope.setattributeList(result, id);
                                });
                            } else if ($scope.tempfilter[$scope.nameSpace + $scope.Field_API_Name] == 'Content Language') {
                                
                                $scope.getContentLanguage().then(function(result) {
                                    $scope.setattributeList(result, id);
                                });
                            } else if ($scope.tempfilter[$scope.nameSpace + $scope.Field_API_Name] == 'Content Types') {
                                
                                $scope.getContentTypes().then(function(result) {
                                    $scope.setattributeList(result, id);
                                });
                            } else if (!$scope.tempfilter[$scope.nameSpace + $scope.From_Mapping]) {
                                
                                $scope.getFilterAttributes(id).then(function(result) {
                                    $scope.setattributeList(result, id);
                                });
                            } else if ($scope.tempfilter[$scope.nameSpace + $scope.From_Mapping]) {
                                
                                $scope.getRelatedFilterAttributes(id).then(function(result) {
                                    $scope.setattributeList(result, id);
                                });
                            }
                            var index = $scope.filterIds.indexOf($scope.tempfilter[$scope.nameSpace + $scope.Field_API_Name]);

                            if (index != -1) {
                                $scope.filterIds.splice(index, 1);
                            }
                        } else if (!$scope.tempfilter[$scope.nameSpace + $scope.From_Mapping]) {
                            $scope.attributeList = $scope.filterAttributeMap[id];
                            $scope.operation = $scope.filterOperationMap[id];
                            $scope.attributesLoading = false;
                        }
                    }

                    $scope.setattributeList = function(result, id) {
                        $scope.attributeList = result; 

                        if ($scope.attributeList.length > 200) {
                            $scope.hasBulkRecords = true;
                            $scope.attributeList.splice(200, 1);
                        }
                        $scope.filterAttributeMap[id] = $scope.attributeList;
                        $scope.attributesLoading = false;
                    }

                    $scope.clearAttributeSearch = function(id) {
                        $scope.isError = false;
                        $scope.attributesLoading = true;
                        $scope.searchAttText = '';
                        
                        angular.forEach(
                            $scope.attributeList,
                            function(att) {
                                
                                if (att.isSelected && $scope.previouslySelectedAttLabel.indexOf(att.label) != -1) {
                                    $scope.previouslySelectedAtt.push(att);
                                    $scope.previouslySelectedAttLabel.push(att.label);
                                }
                            }
                        );
                        $scope.tempAtts = [];

                        $scope.searchRelatedMAppingAttributes(id).then(function(result) {
                            $scope.attributeList = result;
                            $scope.showextraattributes = true;
                            $scope.basicFilterMap[id] = false;
                            $scope.tobeDelete = [];

                            angular.forEach(
                                $scope.attributeList,
                                function(att) {
                                    
                                    if ($scope.previouslySelectedAttLabel.indexOf(att.label) >= 0) {
                                        att.isSelected = true;
                                        $scope.tobeDelete.push(att.label);
                                    }
                                }
                            );

                            angular.forEach(
                                $scope.previouslySelectedAtt,
                                function(prevAtt) {
                                    
                                    if ($scope.tobeDelete.indexOf(prevAtt.label) < 0) {
                                        $scope.tempAtts.push(prevAtt);
                                    }
                                }
                            );
                            $scope.filterAttributeMap[id] = $scope.tempAtts;
                            //productService.isloading(false);
                            $scope.attributesLoading = false;
                            $scope.searchAttText = '';
                        });
                    }

                    $scope.searchRelatedAttributes = function($event, id) {
                        var keyCode = $event.which || $event.keyCode;

                        if (keyCode === 13) {
                            
                            if ($scope.searchAttText.length > 1 ) {
                                $scope.isError = false;
                                //productService.isloading(true);
                                $scope.attributesLoading = true;

                                angular.forEach(
                                    $scope.attributeList,
                                    function(att) {
                                        
                                        if (att.isSelected && $scope.previouslySelectedAttLabel.indexOf(att.label) != -1) {
	                                        $scope.previouslySelectedAtt.push(att);
	                                        $scope.previouslySelectedAttLabel.push(att.label);
	                                    }
                                    }
                                );
                                $scope.tempAtts = [];

                                $scope.searchRelatedMAppingAttributes(id).then(function(result) {
                                    $scope.attributeList = result;
                                    $scope.showextraattributes = true;
                                    $scope.basicFilterMap[id] = false;
                                    $scope.tobeDelete = [];

                                    angular.forEach(
                                        $scope.attributeList,
                                        function(att) {
                                            
                                            if ($scope.previouslySelectedAttLabel.indexOf(att.label) >= 0) {
                                                att.isSelected = true;
                                                $scope.tobeDelete.push(att.label);
                                            }
                                        }
                                    );

                                    angular.forEach(
                                        $scope.previouslySelectedAtt,
                                        function(prevAtt) {
                                            
                                            if ($scope.tobeDelete.indexOf(prevAtt.label) < 0) {
                                                $scope.tempAtts.push(prevAtt);
                                            }
                                        }
                                    );
                                    $scope.filterAttributeMap[id] = $scope.tempAtts;
                                    //productService.isloading(false);
                                    $scope.attributesLoading = false;
                                    $scope.searchAttText = '';
                                });
                            } else {
                                $scope.isError = true;
                            }
                        }
                    }

                    $scope.selectAllAttributes = function(id) {
                        
                        angular.forEach(
                            $scope.basicFilters,
                            function(filter) {

                                if (filter.dataMapping[$scope.nameSpace + $scope.Field_API_Name] == id) {
                                    $scope.tempList = $scope.filterAttributeMap[filter.dataMapping[$scope.nameSpace + $scope.Field_API_Name]];

                                    angular.forEach(
                                        $scope.tempList,
                                        function(item) {

                                            if (item != null && item != '') {
                                                item.isSelected = true;
                                            }
                                        }
                                    );
                                    $scope.filterAttributeMap[filter.dataMapping[$scope.nameSpace + $scope.Field_API_Name]] = $scope.tempList;
                                }
                            }
                        );
                    }

                    $scope.clearAllAttributes = function(id) {
                        
                        if (id == null || id == '') {
                            productService.isloading(true);
                            var alreayFilterAppiled = false;
                            $scope.isFilterApplied = false;
                            
                            if ($scope.selectedAttributes.length > 0) {
                                alreayFilterAppiled = true;
                            }
                            
                            if ($scope.previouslySelectedAttLabel.length > 0) {
                                alreayFilterAppiled = true;
                            }
                            $scope.relatedFilterMapAccount = {};
                            $scope.relatedFilterMapContact = {};
                            $scope.relatedFilterMapContent = {};
                            
                            angular.forEach(
                                $scope.filterAttributeMap,
                                function(attList, filterId) {

                                    angular.forEach(
                                        attList,
                                        function(attWrapper) {
                                            attWrapper['isSelected'] = false;
                                        }
                                    );
                                }
                            );
                            $scope.selectedAttributes = [];
                            $scope.previouslySelectedAttLabel = [];
                            $scope.callFilterFunction('', alreayFilterAppiled);
                        } else {

                            angular.forEach(
                                $scope.basicFilters,
                                function(filter) {

                                    if (filter.dataMapping[$scope.nameSpace + $scope.Field_API_Name] == id) {
                                        $scope.tempList = $scope.filterAttributeMap[filter.dataMapping[$scope.nameSpace + $scope.Field_API_Name]];

                                        angular.forEach(
                                            $scope.tempList,
                                            function(tempAtt) {

                                                if (tempAtt != null && tempAtt != '') {
                                                    tempAtt.isSelected = false;

                                                    if (tempAtt.label != null && tempAtt.label != '') {
                                                        var index = $scope.previouslySelectedAttLabel.indexOf(tempAtt.label);
                                                        $scope.previouslySelectedAttLabel.splice(index, 1); 
                                                    }
                                                }
                                            }
                                        );
                                        $scope.filterAttributeMap[filter.dataMapping[$scope.nameSpace + $scope.Field_API_Name]] = $scope.tempList;
                                    }
                                }
                            );
                        }
                    }

                    $scope.clearAll = function() {
                        $scope.searchText = '';
                        $scope.clearAllAttributes('');
                        $scope.isActive = true;
                        $scope.searchBoxError = false;
                        productService.isloading(true);
                        $scope.isSearchApplied = true;
                        productService.searchText($scope.searchText);
                        $scope.clearSearch();
                        $scope.isAppliedFiltersOpen = false;
                    }

                    $scope.saveAttributes = function() {
                        productService.isloading(true);
                        $scope.showAllFilters = false;
                        $scope.showextraattributes = false;
                        var alreayFilterAppiled = false;
                        var relatedFilterId = '';
                        var tempAttributeMap = {};

                        angular.forEach(
                            $scope.basicFilters,
                            function(filter) {
                                $scope.basicFilterMap[filter.dataMapping[$scope.nameSpace + $scope.Field_API_Name]] = false;
                            }
                        );
                        
                        if ($scope.selectedAttributes.length > 0) {
                            alreayFilterAppiled = true;
                            $scope.isFilterApplied = true;
                        }
                        
                        if ($scope.previouslySelectedAttLabel.length > 0) {
                            alreayFilterAppiled = true;
                            $scope.isFilterApplied = true;
                        }
                        
                        angular.forEach(
                        	$scope.filterAttributeMap,
                        	function(array, filterId) {

                                for (var i = 0; i < $scope.basicFilters.length; i++) {
		                            
                                    if ($scope.basicFilters[i].dataMapping[$scope.nameSpace + $scope.Field_API_Name] == filterId) {
		                                $scope.filterObj = $scope.basicFilters[i].dataMapping;
		                                break;
		                            }
		                        }

	                            if ($scope.filterObj != null
	                            		&& $scope.filterObj[$scope.nameSpace + $scope.Field_API_Name] == filterId
	                            		&& $scope.filterObj[$scope.nameSpace + $scope.From_Mapping]) {
	                                relatedFilterId = filterId;
	                                
                                    for (var i = 0; i < $scope.attributeList.length; i++) {

                                        if ($scope.attributeList[i].isSelected) {

	                                        if ($scope.selectedAttributes.indexOf($scope.attributeList[i].label) < 0) {
		                                        $scope.selectedAttributes.push($scope.attributeList[i].label);
	                                        }

	                                        if ($scope.previouslySelectedAttLabel.indexOf($scope.attributeList[i].label) < 0) {
	                                            $scope.previouslySelectedAtt.push($scope.attributeList[i]);
	                                            $scope.previouslySelectedAttLabel.push($scope.attributeList[i].label);
                                                
	                                            if ($scope.filterAttributeMap[filterId].indexOf($scope.attributeList[i]) == -1) {
		                                            $scope.filterAttributeMap[filterId].push($scope.attributeList[i]);
	                                            }
	                                        }
	                                    }
	                                }
	                                
                                    for (var i = 0; i < array.length; i++) {

	                                    if (array[i].isSelected) {

	                                    	if ($scope.selectedAttributes.indexOf(array[i].label) < 0) {
		                                        $scope.selectedAttributes.push(array[i].label);
	                                        }
	                                        
                                            if ($scope.previouslySelectedAttLabel.indexOf(array[i].label) < 0) {
	                                            $scope.previouslySelectedAtt.push(array[i]);
	                                            $scope.previouslySelectedAttLabel.push(array[i].label);
	                                        }
	                                    }
	                                }
	                            } else {
	                                
                                    for (var i = 0; i < array.length; i++) {

	                                    if (array[i].isSelected) {

	                                        if (filterId == 'Referenceability') {
	                                            $scope.selectedAttributes.push(array[i].refType.Id);
	                                        } else if (filterId == 'Content Types') {
	                                            $scope.selectedAttributes.push(array[i].contentTypeName);
	                                        } else if (filterId == 'Content Language') {
	                                            $scope.selectedAttributes.push(array[i].contentLanguageName);
	                                        } else if ($scope.filterObj != null && !$scope.filterObj[$scope.nameSpace + $scope.From_Mapping]) {
	                                            $scope.selectedAttributes.push(array[i].attId);
	                                        }
	                                    }
	                                }
	                            }
                        	}
                        );
                        $scope.callFilterFunction(relatedFilterId, alreayFilterAppiled);
                    }

                    $scope.filterRelatedAccountRecords = function() {
                        var deferred = $q.defer();
                        var isInheritableMappingFromContact = false;
                        var isInheritableMappingFromContent = false;
                        $scope.mappingIds = [];
                        
                        angular.forEach(
                            $scope.relatedFilterMapContact,
                            function(contactids, attMapKey) {
                                $scope.mappingIds.push(attMapKey);
                            }
                        );

                        angular.forEach(
                            $scope.relatedFilterMapContent,
                            function(contentids, attMapKey) {
                                $scope.mappingIds.push(attMapKey);
                            }
                        );

                        $scope.getMapping($scope.mappingIds).then(function(result) {
                            $scope.inheritableAccountIds = [];
                            $scope.attributeMapInheritableContactIds = [];
                            $scope.attributeMapInheritableContentIds = [];
                            $scope.tempIds = [];
                            var count = 0;
                            
                            angular.forEach(
                                result,
                                function(attMapping) {
                                    
                                    if ($scope.relatedFilterMapContact[attMapping.Id] != null) {
                                        isInheritableMappingFromContact = true;
                                    }
                                        
                                    if ($scope.relatedFilterMapContent[attMapping.Id] != null) {
                                        isInheritableMappingFromContent = true;
                                    }
                                }
                            );
                            
                            angular.forEach( 
                                $scope.relatedFilterMapContact,
                                function(contactids, attMapKey) {
                                    
                                    for (var i = 0; i < contactids.length; i++) {

                                        if (count == 0) {
                                            $scope.tempIds.push(contactids[i]);
                                        } else if ($scope.attributeMapInheritableContactIds.indexOf(contactids[i]) >= 0) {
                                            $scope.tempIds.push(contactids[i]);
                                        }
                                    }
                                    $scope.attributeMapInheritableContactIds = [];
                                    $scope.attributeMapInheritableContactIds = $scope.tempIds;
                                    $scope.tempIds = [];
                                    ++count;
                                }
                            );
                            $scope.tempIds = [];
                            count = 0;
                            
                            angular.forEach(
                                $scope.relatedFilterMapContent,
                                function(contentids, attMapKey) {
                                    
                                    for (var i = 0; i < contentids.length; i++) {

                                        if (count == 0) {
                                            $scope.tempIds.push(contentids[i]);
                                        } else if ($scope.attributeMapInheritableContentIds.indexOf(contentids[i]) >= 0) {
                                            $scope.tempIds.push(contentids[i]);
                                        }
                                    }
                                    $scope.attributeMapInheritableContentIds = [];
                                    $scope.attributeMapInheritableContentIds = $scope.tempIds;
                                    $scope.tempIds = [];
                                    ++count;
                                }
                            );
                            
                            $scope.getContacts($scope.attributeMapInheritableContactIds, isInheritableMappingFromContact).then(function(result) {
                                
                                if (result != '') {
                                    $scope.inheritableAccountIds = result;
                                }
                                
                                $scope.getContents($scope.attributeMapInheritableContentIds, isInheritableMappingFromContent).then(function(resultcontent) {
                                    
                                    if (resultcontent != '') {

                                        angular.forEach(resultcontent, function(contentId) {
                                            $scope.inheritableAccountIds.push(contentId);
                                        });
                                    }
                                    $scope.tempIds = [];
                                    $scope.accountMappedIds = [];
                                    $scope.mappingSelected = false;
                                    
                                    if (isInheritableMappingFromContent || isInheritableMappingFromContact) {
                                        $scope.mappingSelected = true;
                                        
                                        if ($scope.inheritableAccountIds != '' && $scope.inheritableAccountIds.length > 0) {
                                            
                                            angular.forEach($scope.inheritableAccountIds, function(accId) {
                                                $scope.accountMappedIds.push(accId);
                                            });
                                        }
                                        count = 1;
                                    } else {
                                        count = 0;
                                    }

                                    angular.forEach(
                                        $scope.relatedFilterMapAccount,
                                        function(accountids, attMapKey) {
                                            
                                            if (accountids.length > 0) {
                                                
                                                for (var i = 0; i < accountids.length; i++) {
                                                    
                                                    if (count == 0) {
                                                        $scope.tempIds.push(accountids[i]);
                                                    } else if ($scope.accountMappedIds.indexOf(accountids[i]) >= 0) {
                                                        $scope.tempIds.push(accountids[i]);
                                                    }
                                                }
                                                $scope.accountMappedIds = [];
                                                $scope.accountMappedIds = $scope.tempIds;
                                                $scope.tempIds = [];
                                                ++count;
                                                $scope.mappingSelected = true;
                                            }
                                        }
                                    );

                                    for (var i = 0; i < $scope.accountMappedIds.length; i++) {
                                        
                                        if ($scope.inheritableAccountIds.indexOf($scope.accountMappedIds[i]) < 0) {
                                            $scope.attributeMapInheritableAccountIds.push($scope.accountMappedIds[i]);
                                        } else {
                                            $scope.mappingSelected = true;
                                        }
                                    }
                                    deferred.resolve('rekha');
                                }, function() {
                                    console.log('error');
                                });
                            }, function() {
                                console.log('error');
                            });
                        }, function() {
                            console.log('error');
                        });
                        return deferred.promise;
                    }

                    $scope.filterRelatedContactRecords = function(){
                        var deferred = $q.defer();
                        var isInheritableMapping = false;
                        $scope.mappingIds = [];
                        var count = 0;
                        
                        angular.forEach(
                            $scope.relatedFilterMapAccount,
                            function(accountids, attMapKey) {
                                $scope.mappingIds.push(attMapKey);
                            }
                        );
                        $scope.mappingContactSelected = false;
                        
                        $scope.getMapping($scope.mappingIds).then(function(result) {
                            
                            if (result.length > 0) {
                                isInheritableMapping = true;
                            }
                            $scope.inheritableContactIds = [];
                            $scope.tempIds = [];

                            $scope.getRelatedContacts($scope.attributeMapInheritableAccountIds, isInheritableMapping).then(function(result) {
                                
                                if (isInheritableMapping) {

                                    if (result.length > 0) {
                                        $scope.inheritableContactIds = result;
                                        $scope.mappingContactSelected = true;
                                        $scope.contactMappedIds = $scope.inheritableContactIds;
                                        count = 1;
                                    }
                                } else {
                                    count = 0;
                                }
                                
                                angular.forEach($scope.relatedFilterMapContact, function(contactids, attMapKey) {
                                    
                                    for (var i = 0; i < contactids.length; i++) {

                                        if (count == 0) {
                                            $scope.tempIds.push(contactids[i]);
                                        } else if ($scope.contactMappedIds.indexOf(contactids[i]) >= 0) {
                                            $scope.tempIds.push(contactids[i]);
                                        }
                                    }
                                    $scope.contactMappedIds = [];
                                    $scope.contactMappedIds = $scope.tempIds;
                                    $scope.tempIds = [];
                                    ++count;

                                    if ($scope.filterAttributeMap[attMapKey] != null) {
                                        var attList = $scope.filterAttributeMap[attMapKey];
                                        
                                        for (var i = 0; i < attList.length; i++) {

                                            if (attList[i].isSelected) {
                                                $scope.mappingContactSelected = true;
                                                break;
                                            }
                                        }
                                    }
                                });
                                deferred.resolve('rekha');
                            }, function() {
                                console.log('error');
                            });
                        }, function() {
                            console.log('error');
                        });
                        return deferred.promise;
                    }

                    $scope.filterRelatedContentRecords = function() {
                        var deferred = $q.defer();
                        var isInheritableMapping = false;
                        $scope.mappingIds = [];
                        var count = 0;
                        
                        angular.forEach(
                        	$scope.relatedFilterMapAccount,
                        	function(accountids, attMapKey) {
                                $scope.mappingIds.push(attMapKey);
                        	}
                        );
                        $scope.mappingContentSelected = false;

                        $scope.getMapping($scope.mappingIds).then(function(result) {
                            
                            if (result.length > 0) {
                                isInheritableMapping = true;
                            }
                            $scope.inheritableContentIds = [];
                            $scope.tempIds = [];
                            
                            $scope.getRelatedContents($scope.attributeMapInheritableAccountIds, isInheritableMapping).then(function(result) {
                                
                                if (isInheritableMapping) {
                                    $scope.inheritableContentIds = result;
                                    $scope.mappingContentSelected = true;
                                    $scope.contentMappedIds = $scope.inheritableContentIds;
                                    count = 1;
                                } else {
                                    count = 0;
                                }

                                angular.forEach(
                                	$scope.relatedFilterMapContent,
                                	function(contactids, attMapKey) {
	                                    
                                        for (var i = 0; i < contactids.length; i++) {

	                                        if (count == 0) {
	                                            $scope.tempIds.push(contactids[i]);
	                                        } else if ($scope.contentMappedIds.indexOf(contactids[i]) >= 0) {
	                                            $scope.tempIds.push(contactids[i]);
	                                        }
	                                    }
	                                    $scope.contentMappedIds = [];
	                                    $scope.contentMappedIds = $scope.tempIds;
	                                    $scope.tempIds = [];
	                                    ++count;
	                                    
                                        if ($scope.filterAttributeMap[attMapKey] != null) {
	                                        var attList = $scope.filterAttributeMap[attMapKey];

	                                        for (var i = 0; i< attList.length; i++) {

	                                            if (attList[i].isSelected) {
	                                                $scope.mappingContentSelected = true;
	                                                break;
	                                            }
	                                        }
	                                    }
                                	}
                                );
                                deferred.resolve('rekha');
                            }, function() {
                                console.log('error');
                            });
                        }, function() {
                            console.log('error');
                        });
                        return deferred.promise;
                    }

                    $scope.clickAttribute = function(filterId, attid) {
                        var relatedFilterId = '';
                        var flag = false;

                        angular.forEach(
                            $scope.basicFilters,
                            function(filter) {

                                if (filter.dataMapping[$scope.nameSpace + $scope.Field_API_Name] == filterId) {

                                    if (filter.dataMapping[$scope.nameSpace + $scope.From_Mapping]) {
                                        relatedFilterId = filterId;
                                    }
                                    $scope.tempList = $scope.filterAttributeMap[filter.dataMapping[$scope.nameSpace + $scope.Field_API_Name]];

                                    angular.forEach(
                                        $scope.tempList,
                                        function(item) {
                                            
                                            if (filterId == 'Referenceability' && item != null && item != '') {

                                                if (item.refType.Id == attid) {
                                                    item.isSelected = !item.isSelected;
                                                }
                                            } else if (filterId == 'Content Types' && item != null && item != '') {
                                                
                                                if (item.contentTypeName == attid) {
                                                    item.isSelected = !item.isSelected;
                                                }
                                            } else if (filterId == 'Content Language' && item != null && item != '') {
                                                
                                                if (item.contentLanguageName == attid) {
                                                    item.isSelected = !item.isSelected;
                                                }
                                            } else if (filter.dataMapping[$scope.nameSpace + $scope.From_Mapping] && item != null && item != '') {
                                                
                                                if (item.label == attid) {
                                                    item.isSelected = !item.isSelected;
                                                    flag = true;
                                                }
                                            } else if (item != null && item != '') { 
                                                
                                                if (item.attId == attid) {
                                                    item.isSelected = !item.isSelected;
                                                }
                                            }
                                        }
                                    );
                                    $scope.filterAttributeMap[filter.dataMapping[$scope.nameSpace + $scope.Field_API_Name]] = $scope.tempList;
                                }
                            }
                        );
                        
                        if (relatedFilterId != '' && !flag) {
	                        
                            angular.forEach(
                                $scope.attributeList,
                                function(att) {

                                    if (att != null && att != '') {

                                        if (att.label == attid) {
                                            att.isSelected = !att.isSelected;
                                        }
                                    }
                                }
                            );
	                    }
                        
                        if ($scope.selectedAttributes.indexOf(attid) >= 0) {
                            var alreayFilterAppiled = false;
                            
                            if ($scope.selectedAttributes.length > 0) {
                                alreayFilterAppiled = true;
                            }
                            
                            if ($scope.previouslySelectedAttLabel.length > 0) {
                                alreayFilterAppiled = true;
                            }
                            var index = $scope.selectedAttributes.indexOf(attid);
                            $scope.selectedAttributes.splice(index, 1);  
                            productService.isloading(true);
                            $scope.attributesLoading = true;
                            index = $scope.previouslySelectedAttLabel.indexOf(attid);
                            $scope.previouslySelectedAttLabel.splice(index, 1);  
                            $scope.callFilterFunction(relatedFilterId, alreayFilterAppiled);
                        }
                    }

                    $scope.callFilterFunction = function(relatedFilterId, alreayFilterAppiled) {
                        
                        $scope.filterRecords($scope.previouslySelectedAttLabel, relatedFilterId).then(function(result) {
                            $scope.currentMap = result;
                            
                            if (relatedFilterId != '') {
                                delete $scope.relatedFilterMapAccount[relatedFilterId];
                                delete $scope.relatedFilterMapContact[relatedFilterId];
                                delete $scope.relatedFilterMapContent[relatedFilterId];
                            }
                            var breakFlag = true;

                            angular.forEach(
                            	$scope.filterAttributeMap[relatedFilterId],
                            	function(item) {
                            		
                                    if (breakFlag) {

                            			if (item.isSelected) {
                            				breakFlag = false;
                            			}
                            		}
                            	}
                            );

                            if (!breakFlag) {
	                            
                                angular.forEach(
	                            	$scope.currentMap,
	                            	function(ids, object) {
		                                
                                        if (object == 'account') {
		                                    $scope.relatedFilterMapAccount[relatedFilterId] = ids;
		                                }
		                                
                                        if (object == 'contact') {
		                                    $scope.relatedFilterMapContact[relatedFilterId] = ids;
		                                }
		                                
                                        if (object == 'content') {
		                                    $scope.relatedFilterMapContent[relatedFilterId] = ids;
	                                    }
	                            	}
	                            );
                            }

                            $scope.filterRelatedAccountRecords().then(function(result) {
                                
                                $scope.filterRelatedContactRecords().then(function(result) {

                                    $scope.filterRelatedContentRecords().then(function(result) {

                                        if (alreayFilterAppiled
                                                || $scope.selectedAttributes.length > 0
                                                || $scope.mappingSelected
                                                || $scope.mappingContentSelected
                                                || $scope.mappingContactSelected) {
                                            
                                            if (!$scope.isSearchApplied) {
                                                $scope.searchText = '';
                                            }
                                            productService.callChild($scope.filterAttributeMap, $scope.filterOperationMap, $scope.accountMappedIds, $scope.mappingSelected, $scope.contactMappedIds, $scope.mappingContactSelected, $scope.contentMappedIds, $scope.mappingContentSelected, $scope.mappedFilterIds, $scope.stageFilterId);
                                        } else {
                                            productService.isloading(false);
                                        }
                                        $scope.attributesLoading = false;
                                    }, function() {
                                        console.log('error');
                                    });
                                }, function() {
                                    console.log('error');
                                });
                            }, function() {
                                console.log('error');
                            });
                        }, function() {
                            console.log('error');
                        });
                    }

                    $scope.search = function($event) {
                        var keyCode = $event.which || $event.keyCode;

                        if (keyCode === 13) {

                            if ($scope.searchText.length > 1) {
                                $scope.isActive = true;
                                $scope.searchBoxError = false;
                                productService.isloading(true);
                                $scope.isSearchApplied = true;
                                productService.searchText($scope.searchText);
                            } else {
                                $scope.searchBoxError = true;
                            }
                        } else {
                            $scope.isActive = false;
                        }
                    }

                    $scope.clearSearch = function() {
                        productService.isloading(true); 
                        $scope.searchText = '';
                        productService.searchText(''); 
                        $scope.isSearchApplied = false;
                    }

                    $scope.changeOperation = function(key, value) {
                        $scope.filterOperationMap[key] = value;
                    }

                    $scope.savefilterOperation = function() {
                        $scope.showAdvanceFilters = false;
                    }

                    $scope.$on('toggleFiltersModalEvent', function(e, value) {
                        $scope.showFiltersModal = !$scope.showFiltersModal;
                    });

                    $scope.closeFiltersModal = function() {
                        $scope.showFiltersModal = false;
                    }

                    $scope.toggleAppliedFilters = function() {
                        $scope.isAppliedFiltersOpen = !$scope.isAppliedFiltersOpen;
                    }

                    $scope.toggleFilterOperatorPanel = function() {
                        $scope.showFilterOperatorPanel = !$scope.showFilterOperatorPanel;
                    }

                    $scope.changeFilterOperation = function(newOperation) {
                        $scope.filterOperationMap[$scope.tempfilter[$scope.nameSpace + $scope.Field_API_Name]] = newOperation;
                    }
                }
            );
        </script>
    </head>
    
    <body>
        <div ng-controller="sf1FilterCtrl" ng-init="intialFunction()" ng-cloak="ng-cloak">
            <div style="background-color: #f5f7fa" ng-class="{'topPadding' : isAppliedFiltersOpen}">
                <div class="slds-grid slds-grid_align-spread appliedFiltersBlock" ng-class="{'appliedFiltersBlockOpen' : isAppliedFiltersOpen}">
                    <div style="text-align: center; line-height: 1.75rem" ng-show="selectedAttributes.length == 0">{!$Label.No_Filters_Applied}</div>
                    <div ng-show="selectedAttributes.length > 0" style="width: -webkit-fill-available">
                        <div ng-repeat="filter in basicFilters" style="display: inline-block">
                            <div ng-repeat="att in filterAttributeMap[filter.dataMapping[nameSpace + Field_API_Name]]" ng-show="att.isSelected" style="display: inline-block; margin: 1px">
                                <span class="slds-pill slds-pill_link" ng-show="filter.dataMapping[nameSpace + Field_API_Name] == 'Referenceability'">
                                    <a class="slds-pill__action">
                                        <span class="slds-pill__label">{{att.refType.Name}}</span>
                                    </a>
                                    <a class="slds-button slds-button_icon slds-button_icon slds-pill__remove" ng-click="clickAttribute(filter.dataMapping[nameSpace + Field_API_Name], att.refType.Id)">
                                        <svg class="slds-button__icon" aria-hidden="true">
                                            <use xlink:href="{!URLFOR($Resource.LightningCSS_2_3, '/assets/icons/utility-sprite/svg/symbols.svg#close')}"></use>
                                        </svg>
                                        <span class="slds-assistive-text">Remove</span>
                                    </a>
                                </span>
                                <span class="slds-pill slds-pill_link" ng-show="filter.dataMapping[nameSpace + Field_API_Name] == 'Content Language'">
                                    <a class="slds-pill__action">
                                        <span class="slds-pill__label">{{att.contentLanguageName}}</span>
                                    </a>
                                    <a class="slds-button slds-button_icon slds-button_icon slds-pill__remove" ng-click="clickAttribute(filter.dataMapping[nameSpace + Field_API_Name], att.contentLanguageName)">
                                        <svg class="slds-button__icon" aria-hidden="true">
                                            <use xlink:href="{!URLFOR($Resource.LightningCSS_2_3, '/assets/icons/utility-sprite/svg/symbols.svg#close')}"></use>
                                        </svg>
                                        <span class="slds-assistive-text">Remove</span>
                                    </a>
                                </span>
                                <span class="slds-pill slds-pill_link" ng-show="filter.dataMapping[nameSpace + Field_API_Name] == 'Content Types'">
                                    <a class="slds-pill__action">
                                        <span class="slds-pill__label">{{att.contentTypeName}}</span>
                                    </a>
                                    <a class="slds-button slds-button_icon slds-button_icon slds-pill__remove" ng-click="clickAttribute(filter.dataMapping[nameSpace + Field_API_Name], att.contentTypeName)">
                                        <svg class="slds-button__icon" aria-hidden="true">
                                            <use xlink:href="{!URLFOR($Resource.LightningCSS_2_3, '/assets/icons/utility-sprite/svg/symbols.svg#close')}"></use>
                                        </svg>
                                        <span class="slds-assistive-text">Remove</span>
                                    </a>
                                </span>
                                <span class="slds-pill slds-pill_link" ng-show="filter.dataMapping[nameSpace + Field_API_Name] != 'Referenceability' && filter.dataMapping[nameSpace + Field_API_Name] != 'Content Language' && filter.dataMapping[nameSpace + Field_API_Name] != 'Content Types' && filter.dataMapping[nameSpace + From_Mapping]">
                                    <a class="slds-pill__action">
                                        <span class="slds-pill__label">{{att.label}}</span>
                                    </a>
                                    <a class="slds-button slds-button_icon slds-button_icon slds-pill__remove" ng-click="clickAttribute(filter.dataMapping[nameSpace + Field_API_Name], att.label)">
                                        <svg class="slds-button__icon" aria-hidden="true">
                                            <use xlink:href="{!URLFOR($Resource.LightningCSS_2_3, '/assets/icons/utility-sprite/svg/symbols.svg#close')}"></use>
                                        </svg>
                                        <span class="slds-assistive-text">Remove</span>
                                    </a>
                                </span>
                                <span class="slds-pill slds-pill_link" ng-show="filter.dataMapping[nameSpace + Field_API_Name] != 'Referenceability' && filter.dataMapping[nameSpace + Field_API_Name] != 'Content Language' && filter.dataMapping[nameSpace + Field_API_Name] != 'Content Types' && !filter.dataMapping[nameSpace + From_Mapping]">
                                    <a class="slds-pill__action">
                                        <span class="slds-pill__label">{{att.attName}}</span>
                                    </a>
                                    <a class="slds-button slds-button_icon slds-button_icon slds-pill__remove" ng-click="clickAttribute(filter.dataMapping[nameSpace + Field_API_Name], att.attId)">
                                        <svg class="slds-button__icon" aria-hidden="true">
                                            <use xlink:href="{!URLFOR($Resource.LightningCSS_2_3, '/assets/icons/utility-sprite/svg/symbols.svg#close')}"></use>
                                        </svg>
                                        <span class="slds-assistive-text">Remove</span>
                                    </a>
                                </span>
                            </div>
                        </div>
                    </div>
                    <div>
                        <a class="slds-button slds-button_icon" ng-click="toggleAppliedFilters()" ng-show="!isAppliedFiltersOpen">
                            <svg class="slds-button__icon" aria-hidden="true">
                                <use xlink:href="{!URLFOR($Resource.LightningCSS_2_3, '/assets/icons/utility-sprite/svg/symbols.svg#chevrondown')}"></use>
                            </svg>
                        </a>
                        <a class="slds-button slds-button_icon" ng-click="toggleAppliedFilters()" ng-show="isAppliedFiltersOpen">
                            <svg class="slds-button__icon" aria-hidden="true">
                                <use xlink:href="{!URLFOR($Resource.LightningCSS_2_3, '/assets/icons/utility-sprite/svg/symbols.svg#chevronup')}"></use>
                            </svg>
                        </a>
                    </div>
                    <div class="utilityBar slds-grid slds-grid_align-space" ng-show="selectedAttributes.length > 0">
                        <div style="display: inline-block; text-align: center">
                            <span class="slds-icon_container slds-icon_container_circle slds-icon-action-close customIconContainer" ng-click="clearAll()" style="line-height: 1.2 !important">
                                <svg class="slds-icon slds-icon_xx-small" aria-hidden="true">
                                    <use xlink:href="{!URLFOR($Resource.LightningCSS_2_3, '/assets/icons/utility-sprite/svg/symbols.svg#close')}"></use>
                                </svg>
                            </span>
                            <span style="display: block; font-size: 0.55rem">{!$Label.Clear_All}</span>
                        </div>
                    </div>
                </div>
                <div class="slds-form-element textSearchBlock" ng-class="{'slds-has-error' : searchBoxError}">
                    <div class="slds-form-element__control slds-input-has-icon slds-input-has-icon_right">
                        <svg class="slds-icon slds-input__icon slds-input__icon_right slds-icon-text-default" ng-click="clearSearch()" ng-show="searchText != ''" style="cursor: pointer" aria-hidden="true">
                            <use xlink:href="{!URLFOR($Resource.LightningCSS_2_3, '/assets/icons/utility-sprite/svg/symbols.svg#close')}"></use>
                        </svg>
                        <svg class="slds-icon slds-input__icon slds-input__icon_right slds-icon-text-default" ng-show="searchText == ''" style="cursor: pointer" aria-hidden="true">
                            <use xlink:href="{!URLFOR($Resource.LightningCSS_2_3, '/assets/icons/utility-sprite/svg/symbols.svg#search')}"></use>
                        </svg>
                        <input type="text" ng-model="searchText" ng-keypress="search($event)" class="slds-input" placeholder="{!$Label.Search}" />
                    </div>
                    <div ng-show="searchBoxError" class="slds-form-element__help">{!$Label.Atleast_two_characters}</div>
                </div>
            </div>
            <div class="filtersModal" ng-class="{'filtersModalOpen' : showFiltersModal, 'filtersModalOpen1' : showextraattributes}">
                <div class="slds-grid slds-grid_vertical-align-center slds-wrap slds-p-horizontal_medium slds-p-bottom_xx-small" style="border-bottom: 1px solid lightgray">
                    <div class="slds-size_2-of-3 slds-text-heading_small">{!$Label.RF_Filters}</div>
                    <div class="slds-size_1-of-3" style="text-align: right">
                        <a class="slds-button slds-button_neutral" ng-click="closeFiltersModal()">{!$Label.Done}</a>
                    </div>
                </div>
                <div class="slds-grid slds-grid_vertical-align-start slds-wrap" style="height: 84vh; overflow-y: auto">
                    <div ng-repeat="filter in basicFilters" style="width: 100%">
                        <a class="slds-p-around_small" ng-click="showHideTab(filter.dataMapping[nameSpace + Field_API_Name])" style="border-bottom: 1px solid lightgray; display: block; text-decoration: none">
                            {{filter.dataMapping[nameSpace + Label]}}
                            <span class="slds-icon_container slds-icon-utility-announcement" style="float: right">
                                <svg class="slds-icon slds-icon_x-small slds-icon-text-default" aria-hidden="true">
                                    <use xlink:href="{!URLFOR($Resource.LightningCSS_2_3, '/assets/icons/utility-sprite/svg/symbols.svg#chevronright')}"></use>
                                </svg>
                            </span>
                        </a>
                    </div>
                </div>
            </div>
            <div class="attributesModal" ng-class="{'attributesModalOpen' : showextraattributes}">
                <div class="slds-grid slds-grid_vertical-align-center slds-wrap slds-p-horizontal_medium slds-p-bottom_xx-small slds-m-bottom_small" style="border-bottom: 1px solid lightgray">
                    <div class="slds-size_2-of-3 slds-text-heading_small">{{tempfilter[nameSpace + Label]}}</div>
                    <div class="slds-size_1-of-3" style="text-align: right">
                        <a class="slds-button slds-button_neutral" ng-click="saveAttributes()">{!$Label.Done}</a>
                    </div>
                </div>
                <div class="slds-grid slds-grid_vertical-align-start slds-wrap" style="height: 84vh; overflow-y: auto">
                    <div role="status" ng-show="attributesLoading" class="slds-spinner slds-spinner_medium slds-spinner_brand">
                        <span class="slds-assistive-text">Loading</span>
                        <div class="slds-spinner__dot-a"></div>
                        <div class="slds-spinner__dot-b"></div>
                    </div>
                    <div ng-show="!attributesLoading" ng-init="isError = false">
                        <div class="slds-form-element textSearchBlock" ng-show="tempfilter[nameSpace + From_Mapping] && hasBulkRecords == true" ng-class="{'slds-has-error' : isError}">
                            <div class="slds-form-element__control slds-input-has-icon slds-input-has-icon_right">
                                <svg class="slds-icon slds-input__icon slds-input__icon_right slds-icon-text-default" ng-click="clearAttributeSearch(tempfilter[nameSpace + Field_API_Name])" ng-show="searchAttText != ''" style="cursor: pointer" aria-hidden="true">
                                    <use xlink:href="{!URLFOR($Resource.LightningCSS_2_3, '/assets/icons/utility-sprite/svg/symbols.svg#close')}"></use>
                                </svg>
                                <svg class="slds-icon slds-input__icon slds-input__icon_right slds-icon-text-default" ng-show="searchAttText == ''" style="cursor: pointer" aria-hidden="true">
                                    <use xlink:href="{!URLFOR($Resource.LightningCSS_2_3, '/assets/icons/utility-sprite/svg/symbols.svg#search')}"></use>
                                </svg>
                                <input type="text" ng-model="searchAttText" ng-keypress="searchRelatedAttributes($event, tempfilter[nameSpace + Field_API_Name])"
                                        class="slds-input" placeholder="{!$Label.Search}" />
                            </div>
                            <div ng-show="isError" class="slds-form-element__help">{!$Label.Atleast_two_characters}</div>
                            <div ng-show="!isError" class="slds-form-element__help">{!$Label.BulkRecords}</div>
                        </div>
                        <div ng-repeat="attribute in attributeList" ng-show="attributeList.length > 0" style="width: 100%; padding-bottom: 0.3rem">
                            <div style="display: inline-block; width: 2rem; padding-right: 0.3rem">
                                <img src="{!$Resource.GreenCheck}" ng-show="attribute.isSelected == true" style="float: right; width: 1rem" />
                            </div>
                            <div ng-click="clickAttribute(filterObj[nameSpace + Field_API_Name], attribute.attId)" style="display: inline-block" ng-show="filterObj[nameSpace+Field_API_Name] != null && filterObj[nameSpace+Field_API_Name] != '' && !filterObj[nameSpace + From_Mapping] && filterObj[nameSpace + Field_API_Name] != 'Content Types' && filterObj[nameSpace + Field_API_Name] != 'Content Language' && filterObj[nameSpace + Field_API_Name] != 'Referenceability'">
                                {{attribute.attName}}
                            </div>
                            <div ng-click="clickAttribute(filterObj[nameSpace + Field_API_Name], attribute.label)" style="display: inline-block" ng-show="filterObj[nameSpace + Field_API_Name] != null && filterObj[nameSpace + Field_API_Name] != '' && filterObj[nameSpace+From_Mapping] && filterObj[nameSpace + Field_API_Name] != 'Content Types' && filterObj[nameSpace + Field_API_Name] != 'Content Language' && filterObj[nameSpace + Field_API_Name] != 'Referenceability'">
                                {{attribute.label}}
                            </div>
                            <div ng-click="clickAttribute(filterObj[nameSpace + Field_API_Name], attribute.refType.Id)" style="display: inline-block" ng-show="filterObj[nameSpace + Field_API_Name] == 'Referenceability'">
                                {{attribute.refType.Name}}
                            </div>
                            <div ng-click="clickAttribute(filterObj[nameSpace + Field_API_Name], attribute.contentLanguageName)" style="display: inline-block" ng-show="filterObj[nameSpace + Field_API_Name] == 'Content Language'">
                                {{attribute.contentLanguageName}}
                            </div>
                            <div ng-click="clickAttribute(filterObj[nameSpace + Field_API_Name], attribute.contentTypeName)" style="display: inline-block" ng-show="filterObj[nameSpace + Field_API_Name] == 'Content Types'">
                                {{attribute.contentTypeName}}
                            </div>
                        </div>
                        <div ng-show="attributeList.length == 0">
                            {!$Label.No_Data_Found}
                        </div>
                    </div>
                </div>
                <div class="utilityBar slds-grid slds-grid_align-space" ng-show="showextraattributes">
                    <div style="display: inline-block; text-align: center">
                        <span class="slds-icon_container slds-icon_container_circle slds-icon-action-follow customIconContainer" ng-click="toggleFilterOperatorPanel()">
                            <svg class="slds-icon slds-icon_xx-small" aria-hidden="true">
                                <use xlink:href="{!URLFOR($Resource.LightningCSS_2_3, '/assets/icons/utility-sprite/svg/symbols.svg#crossfilter')}"></use>
                            </svg>
                        </span>
                        <span style="display: block; font-size: 0.55rem">{!$Label.Operator}</span>
                    </div>
                    <div style="display: inline-block; text-align: center">
                        <span class="slds-icon_container slds-icon_container_circle slds-icon-action-close customIconContainer" ng-click="clearAllAttributes(tempfilter[nameSpace + Field_API_Name])">
                            <svg class="slds-icon slds-icon_xx-small" aria-hidden="true">
                                <use xlink:href="{!URLFOR($Resource.LightningCSS_2_3, '/assets/icons/utility-sprite/svg/symbols.svg#close')}"></use>
                            </svg>
                        </span>
                        <span style="display: block; font-size: 0.55rem">{!$Label.Clear}</span>
                    </div>
                    <div style="display: inline-block; text-align: center">
                        <span class="slds-icon_container slds-icon_container_circle slds-icon-action-approval customIconContainer" ng-click="selectAllAttributes(tempfilter[nameSpace + Field_API_Name])">
                            <svg class="slds-icon slds-icon_xx-small" aria-hidden="true">
                                <use xlink:href="{!URLFOR($Resource.LightningCSS_2_3, '/assets/icons/action-sprite/svg/symbols.svg#approval')}"></use>
                            </svg>
                        </span>
                        <span style="display: block; font-size: 0.55rem">{!$Label.Select_All}</span>
                    </div>
                </div>
            </div>
            <div class="operatorContainer" ng-class="{'operatorContainerOpen' : showFilterOperatorPanel}">
                <ul class="slds-dropdown__list" role="menu">
                    <li ng-class="{'slds-is-selected' : (filterOperationMap[tempfilter[nameSpace + Field_API_Name]] == 'and')}" class="slds-dropdown__item" style="margin-left: 0" role="presentation">
                        <a role="menuitemcheckbox" aria-checked="true" ng-click="changeFilterOperation('and')">
                            <span class="slds-truncate">
                                <svg class="slds-icon slds-icon_selected slds-icon_x-small slds-icon-text-default slds-m-right_x-small" aria-hidden="true" style="fill: #1c77c7">
                                    <use xlink:href="{!URLFOR($Resource.LightningCSS_2_3, '/assets/icons/utility-sprite/svg/symbols.svg#check')}"></use>
                                </svg>
                                All
                            </span>
                        </a>
                    </li>
                    <li ng-class="{'slds-is-selected' : (filterOperationMap[tempfilter[nameSpace + Field_API_Name]] == 'or')}" class="slds-dropdown__item" style="margin-left: 0" role="presentation">
                        <a role="menuitemcheckbox" aria-checked="true" ng-click="changeFilterOperation('or')">
                            <span class="slds-truncate">
                                <svg class="slds-icon slds-icon_selected slds-icon_x-small slds-icon-text-default slds-m-right_x-small" aria-hidden="true" style="fill: #1c77c7">
                                    <use xlink:href="{!URLFOR($Resource.LightningCSS_2_3, '/assets/icons/utility-sprite/svg/symbols.svg#check')}"></use>
                                </svg>
                                Any
                            </span>
                        </a>
                    </li>
                </ul>
            </div>
            <div ng-click="toggleFilterOperatorPanel()" ng-show="showFilterOperatorPanel" class="modalBackdrop"></div>
            
        </div>
    </body>
</html>
</apex:component>